C++转换

### dynamic_cast

*dynamic_cast* 只能够用在指向类的指针或者引用上(或者void*)。这种转换的目的是确保目标指针类型所指向的是一个有效且完整的对象。

但*dynamic_cast* 也能downcast(从基类向派生类的转换)当且仅当转过去的指针所指向的目标对象有效且完整。

当发生指向对象不完整情况时，会返回空指针来表示转换失败。倘若是无法完成的引用转换，则会抛出bad_cast 异常。

### static_cast

支持常见隐式转换，基类、继承类互转，并不会有运行时的检查来确保转换到目标类型上的指针所指向的对象有效且完整。

- void*转向任何指针类型；假如该指针是从某指针类型上转到void *，现在再次转到相同的指针类型上去的话，保证转换后的指针本身的值不变。

- 整数，浮点以及枚举类型向枚举类型的转换。

- 显式调用仅有一个参数的构造函数或者是转换操作符(conversion operator)

- 转换到右值引用

- 枚举类的值向整数或浮点的转换

- 任意类型向void的转换，目标值在被求值之后舍弃。

  ### reinterpret_cast

*reinterpret_cast*能够完成任意指针类型向任意指针类型的转换，即使它们毫无关联。该转换的操作结果是出现一份完全相同的二进制复制品，既不会有指向内容的检查，也不会有指针本身类型的检查。

### const_cast

*const_cast*可以用来设置或者移除指针所指向对象的const。例如，要把一个const指针传入一个接受非const指针的函数里:

### typeid

typeid用来检查表达式的类型。

这个操作会返回一个定义在<typeinfo>里面的const对象，这个对象可以同其他用typeid获取的const对象进行==或者!=操作，也可以用过.name()来获取一个表示类型名或者是类名的以空字符结尾的字符串。例如：

```
if (typeid(a) != typeid(b))
  {
    cout << "a and b are of different types:\n";
    cout << "a is: " << typeid(a).name() << '\n';
    cout << "b is: " << typeid(b).name() << '\n';
  }
```

